using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using System.Data;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;

namespace Net.Code.ADONet.SourceGenerators
{
    public static class SourceGenerationHelper
    {
        internal static SourceCode GenerateExtensionClass(MapperInfo mapper)
        {
            using var builder = new SourceBuilder()
                .WriteLine("// <auto-generated>")
                .WriteUsings("System.Data")
                .WriteLine()
                .WriteLine(mapper.Namespace is null ? "" : $"namespace {mapper.Namespace};")
                .WriteLine($"public static class __{mapper.Name}Extension__")
                .WriteOpeningBracket();


            builder.WriteLine($"static class ordinal")
                .WriteOpeningBracket()
                .WriteLine("public static bool __initialized__;");

            foreach (var p in mapper.Properties)
            {
                builder.WriteLine($"public static int {p.Name};");
            }

            builder.WriteClosingBracket();

            builder.WriteLine($"public static {mapper.Name} To{mapper.Name}(this IDataRecord record)")
                .WriteOpeningBracket()
                .WriteLine("if (!ordinal.__initialized__)")
                .WriteOpeningBracket();
            foreach (var p in mapper.Properties)
            {
                builder.WriteLine($"ordinal.{p.Name} = record.GetOrdinal(\"{ToColumnName(p.Name, mapper.NamingConvention)}\");");
            }
            builder
            .WriteLine("System.Threading.Thread.MemoryBarrier();")
            .WriteLine($"ordinal.__initialized__ = true;")
            .WriteClosingBracket();

            builder.WriteLine($"return new {mapper.Name}")
            .WriteOpeningBracket();

            foreach (var p in mapper.Properties)
            {
                if (p.Nullable && p.IsValueType)
                {
                    builder.WriteLine($"{p.Name} = record.IsDBNull(ordinal.{p.Name}) ? null : record.{GetGetMethod(p)}(ordinal.{p.Name}),");
                }
                else
                {
                    builder.WriteLine($"{p.Name} = record.{GetGetMethod(p)}(ordinal.{p.Name}),");
                }
            }

            builder.WriteClosingBracket(true)
                .WriteClosingBracket()
                .WriteClosingBracket()
            ;

            return new(builder.ToString(), $"{mapper.Namespace??"global"}.{mapper.Name}MapFromDataRecordExtension.g.cs");


        }

        private static string ToColumnName(string propertyName, NamingConvention namingConvention)
        {
            return namingConvention switch
            {
                NamingConvention.lowercase => propertyName.ToLowerWithUnderscores(),
                NamingConvention.UPPERCASE => propertyName.ToUpperWithUnderscores(),
                _ => propertyName
            };
        }

        private static string GetGetMethod(PropertyInfo property)
        {
            return $"{property.Type switch
            {
                "Boolean" => nameof(IDataRecord.GetBoolean),
                "Byte" => nameof(IDataRecord.GetByte),
                "Char" => nameof(IDataRecord.GetChar),
                "DateTime" => nameof(IDataRecord.GetDateTime),
                "Decimal" => nameof(IDataRecord.GetDecimal),
                "Double" => nameof(IDataRecord.GetDouble),
                "Guid" => nameof(IDataRecord.GetGuid),
                "Single" => nameof(IDataRecord.GetFloat),
                "Int16" => nameof(IDataRecord.GetInt16),
                "Int32" => nameof(IDataRecord.GetInt32),
                "Int64" => nameof(IDataRecord.GetInt64),
                "String" => nameof(IDataRecord.GetString),
                _ => throw new Exception("Unsupported")
            }}";

        }
    }

    public class PropertyInfo
    {
        public PropertyInfo(IPropertySymbol symbol)
        {
            Name = symbol.Name;
            Nullable = symbol.Type.NullableAnnotation is NullableAnnotation.Annotated;
            IsValueType = symbol.Type.IsValueType;
            Type = symbol.Type switch
            {
                INamedTypeSymbol { TypeArguments: [ITypeSymbol underlyingType] } => underlyingType.Name,
                _ => symbol.Type.Name
            };
        }
        public string Name { get; }
        public string Type { get; }
        public bool Nullable { get; }
        public bool IsValueType { get; }
    }
    public class MapperInfo
    {
        public string? Namespace { get; }
        public string Name { get; }
        internal NamingConvention NamingConvention { get; }
        public MapperInfo(ITypeSymbol type)
        {
            Namespace = type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToString();
            Name = type.Name;
            Properties = type.GetMembers().OfType<IPropertySymbol>().Select(s => new PropertyInfo(s)).ToList();

            NamingConvention = (
                from a in type.GetAttributes()
                where a.AttributeClass?.Name == "MapFromDataRecordAttribute"
                let columnNamingConvention =
                    (from n in a.NamedArguments
                     where n.Key == "ColumnNamingConvention"
                     select n.Value.Value).FirstOrDefault()
                select (NamingConvention?) ((int?)columnNamingConvention)
                ).SingleOrDefault() ?? NamingConvention.PascalCase;
        }
 
        public IEnumerable<PropertyInfo> Properties { get; }
    }
}

enum NamingConvention
{
    PascalCase = 0,
    lowercase = 1,
    UPPERCASE = 2
}

internal static class StringExtensions
{
    public static string ToUpperWithUnderscores(this string source) => string.Join("_", SplitUpperCase(source).Select(s => s.ToUpperInvariant()));
    public static string ToLowerWithUnderscores(this string source) => string.Join("_", SplitUpperCase(source).Select(s => s.ToLowerInvariant()));
    private static IEnumerable<string> SplitUpperCase(string source)
    {
        var wordStart = 0;
        var letters = source.ToCharArray();
        var previous = char.MinValue;
        for (var i = 1; i < letters.Length; i++)
        {
            if (char.IsUpper(letters[i]) && !char.IsWhiteSpace(previous))
            {
                yield return new string(letters, wordStart, i - wordStart);
                wordStart = i;
            }

            previous = letters[i];
        }

        yield return new string(letters, wordStart, letters.Length - wordStart);
    }
}
